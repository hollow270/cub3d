Hereâ€™s a quick and concise performance breakdown ðŸ‘‡
ðŸ”¥ Major performance bottlenecks

mlx_pixel_put (in draw_wall, draw_ceiling, draw_ground, and render_ray_points)

Biggest CPU killer â€” it sends one X11 call per pixel (very slow).

Youâ€™re calling it thousands to millions of times per frame.

Should be replaced with buffered drawing using mlx_new_image, direct pixel writes, then mlx_put_image_to_window() once per frame.

Math-heavy loops (raycasting)

get_horizontal_intercept() and get_vertical_intercept() do up to 100 iterations per ray Ã— WIN_W rays (1000) â†’ ~100,000 map lookups per frame.

Each uses tan(), sin(), cos(), sqrt() â†’ these are expensive.

gc_malloc in ray init functions

Allocating memory per frame (init_raycast_data, etc.) causes fragmentation and slows things down. Should be allocated once and reused.
ðŸ“Š mlx_pixel_put call count per frame

draw_wall: ~WIN_W Ã— wall_height Ã— PX_SIZEÂ²
(â‰ˆ 1000 Ã— ~300 Ã— 1 = ~300k calls)

draw_ceiling + draw_ground: together cover the rest of the screen
(â‰ˆ WIN_W Ã— WIN_H Ã— PX_SIZEÂ² = 1,000,000 calls if they redraw everything)

render_ray_points: adds some more if you visualize rays on minimap (negligible compared to above).

âœ… Total per frame â‰ˆ 1â€“1.5 million mlx_pixel_put calls, which is completely unsustainable in real-time rendering.
ðŸ’¡ Fix summary

Replace all per-pixel mlx_pixel_put() calls with direct writes to an image buffer (g->img.data).

Reuse allocated ray structs.

Precompute sin/cos tables for angles.
TL;DR:
mlx_pixel_put is the main bottleneck (~1M calls/frame).
Math loops (tan/sqrt/sin/cos) and per-frame allocations worsen it
